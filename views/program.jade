doctype html
include mixins
include mapMixins
html
    head
        style.
            .newSite {
                display: flex;
                padding: 10px;
                background: lightgrey;
            }
            .newSite svg {
                margin: 10px;
            }
            .tabulator-tableHolder {
                max-height: 400px !important;
            }
        //link(href="https://unpkg.com/tabulator-tables@4.2.3/dist/css/tabulator.min.css" rel="stylesheet")
        //script(type="text/javascript" src="https://unpkg.com/tabulator-tables@4.2.3/dist/js/tabulator.min.js")
        link(href="/stylesheets/tabulator.min.css" rel="stylesheet")
        script(type="text/javascript" src="/javascripts/tabulator.min.js")
        link(rel='stylesheet', href='/stylesheets/style.css')
        //script(src="https://d3js.org/d3.v5.min.js")
        script(type="text/javascript" src="/javascripts/d3.min.js")
        script(async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAEKjvE48-VV37P2pGBWFphvlrx8BXGDCs&libraries=drawing,geometry")
        script.
            let dataFromServer = !{dataFromServer};
            console.log(dataFromServer);
            let id;
            if(dataFromServer.id) {
                id = !{id};
            }
            let description;
            let taxa = ["Plants", "Birds", "Invertebrate Pollinators"];
            //green, red, yellow, brown, blue
            if(dataFromServer.taxa) {
                taxa = dataFromServer.taxa;
            }
            let habitats = [""];
            let habitatData = [];
            if(dataFromServer.habitatData) {
                habitatData = dataFromServer.habitatData;
            }
            let sites = [];
            if(dataFromServer.sites) {
                sites = dataFromServer.sites;
            }
            let markers = [];
            if(dataFromServer.markers) {
                markers = dataFromServer.markers;
            }
            let table;
            let verificationTable;
            let speciesPresenceTable;
            let columns;
            let speciesSet = new Set();
            let speciesTaxaMap = new Map();
            let startDate;
            function dateStartChanged(input) {
                startDate = new Date(input.value);
            }
            let endDate = Date.now();
            function dateEndChanged(input) {
                endDate = new Date(input.value);
            }
            let timeFrame = "";
            const monthNames = [];
            monthNames[0] = "Jan";
            monthNames[1] = "Feb";
            monthNames[2] = "Mar";
            monthNames[3] = "Apr";
            monthNames[4] = "May";
            monthNames[5] = "Jun";
            monthNames[6] = "Jul";
            monthNames[7] = "Aug";
            monthNames[8] = "Sep";
            monthNames[9] = "Oct";
            monthNames[10] = "Nov";
            monthNames[11] = "Dec";
            function timeFrameSelected(selectObject) {
                timeFrame = selectObject.value;
            }

            let timeSlices;

            window.onload = function (ev) {

                if (dataFromServer.id) {
                    id = !{id};
                    document.getElementById("projectName").value = dataFromServer.name;
                }

                if(dataFromServer.description) {
                    description = dataFromServer.description;
                    document.getElementById("projectDescription").value = dataFromServer.description;
                }

                initMapOnPage();

                let tableData = [{"species": "", "taxa": ""}];

                columns = [
                    {title: "Species", field: "species", editor: "input"},
                    {title: "Taxa", field: "taxa", editor: "select", editorParams: {}}
                    ];

                table = new Tabulator("#example-table", {
                        layoutColumnsOnNewData: true,
                        data: tableData,           //load row data from array
                        layout:"fitData",
                        responsiveLayout: "hide",  //hide columns that dont fit on the table
                        tooltips: true,            //show tool tips on cells
                        addRowPos: "bottom",          //when adding a new row, add it to the top of the table
                        history: true,             //allow undo and redo actions on the table
                        // pagination: "local",       //paginate the data
                        // paginationSize: 7,         //allow 7 rows per page of data
                        movableColumns: true,      //allow column order to be changed
                        resizableRows: true,       //allow row order to be changed
                        initialSort: [             //set the initial sort order of the data
                            {column: "name", dir: "asc"},
                        ],
                        columns: columns,
                        cellEdited: function (cell) {
                            let habitatIndex = [];
                            for (let site in sites) {
                                if (cell._cell.column != null && cell._cell.column.field != null && sites[site].habitat.name == cell._cell.column.field) {
                                    habitatIndex.push(site);
                                }
                            }
                            for(let index in habitatIndex) {
                                if (cell._cell.value) {
                                    sites[habitatIndex[index]].siteSpecies.add(cell._cell.row.data.species);
                                    sites[habitatIndex[index]].taxa.add(cell._cell.row.data.taxa);
                                } else {
                                    sites[habitatIndex[index]].siteSpecies.delete(cell._cell.row.data.species);
                                    sites[habitatIndex[index]].taxa.delete(cell._cell.row.data.taxa);
                                }
                            }
                            if (cell._cell.column != null && cell._cell.column.field == "taxa") {
                                speciesTaxaMap.set(cell._cell.row.data.species, cell._cell.row.data.taxa);
                            }
                        }
                    }
                );

                verificationTable = new Tabulator("#verification-table", {
                    layoutColumnsOnNewData: true
                });
                speciesPresenceTable = new Tabulator("#speciesPresenceTable", {
                    layoutColumnsOnNewData: true
                });

                for (let i = 0; i < taxa.length; i++) {
                    columns[1].editorParams[taxa[i]] = taxa[i];
                    table.setColumns(columns);
                    table.redraw(true);
                    newTaxonLabel = document.createElement("DIV");
                    newTaxonLabel.textContent = taxa[i];
                    document.getElementsByClassName("taxon")[0].appendChild(newTaxonLabel);
                }

                for (let i = 0; i < sites.length; i++) {
                    addSiteToUi(sites[i]);
                }

                for (let i = 0; i < habitatData.length; i++) {
                    addHabitatData(habitatData[i].title);
                    columns.push(habitatData[i]);
                }

                table.setColumns(columns);
                table.redraw(true);

            };

            function generateTableData(button) {
                let columns = [{title: "Species", field: "species"}];
                let speciesRows = [];
                let speciesRowCounter = new Set();
                let data = [];
                for (let site in sites) {
                    if (sites[site].habitat.name === button.innerHTML) {
                        columns.push({title: sites[site].name, field: sites[site].name, formatter: "tickCross"});
                        sites[site].siteSpecies.forEach(function (species) {
                            let containsSpecies = false;
                            for (marker in markers) {
                                if (sites[site].Polygon.Contains(markers[marker].getPosition()) && markers[marker].species == species) {
                                    containsSpecies = true;
                                    break;
                                }
                            }
                            speciesRows.push({
                                siteName: sites[site].name,
                                species: species,
                                containsSpecies: containsSpecies
                            });
                            speciesRowCounter.add(species);
                        });
                    }
                }

                speciesRowCounter.forEach(function (uniqueSpecies) {
                    let newRow = {};
                    newRow.species = uniqueSpecies;
                    columns.forEach(function (column) {
                        newRow[column.title] = false;
                        speciesRows.forEach(function (speciesRow) {
                            if (newRow.species == speciesRow.species && speciesRow.siteName == column.title && speciesRow.containsSpecies) {
                                newRow[column.title] = true;
                            }
                        });
                    });
                    data.push(newRow);
                });
                return {columns, data};
            }

            function verifyTable(button) {
                verificationTable.element.classList.remove("hidden");
                let {columns, data} = generateTableData(button);
                verificationTable.setColumns(columns);
                verificationTable.setData(data);
                verificationTable.redraw(true);
            }

            function surrogateSpeciesByHabitatTable(button) {
                speciesPresenceTable.element.classList.remove("hidden");
                let {columns, data} = generateTableData(button);
                speciesPresenceTable.setColumns(columns);
                speciesPresenceTable.setData(data);
                speciesPresenceTable.redraw(true);
            }

            function initMapOnPage() {
                let center = {lat: 20, lng: 15};
                map = new google.maps.Map(document.getElementById('map'), {
                    zoom: 2, streetViewControl: false,
                    center: center,
                    styles: [{"elementType": "geometry", "stylers": [{"color": "#b6d5e3"}]},
                        {"elementType": "labels.text.fill", "stylers": [{"color": "#6da4c7"}]},
                        {"elementType": "labels.text.stroke", "stylers": [{"color": "#b6d5e3"}]},
                        {"featureType": "administrative", "stylers": [{"visibility": "simplified"}]},
                        {"featureType": "administrative", "elementType": "geometry", "stylers": [{"color": "#f2f2f2"}]},
                        //country borders color is next line
                        {
                            "featureType": "administrative",
                            "elementType": "geometry.stroke",
                            "stylers": [{"color": "#ffffff"}, {"visibility": "on"}]
                        },
                        //main labels color is the next line
                        {
                            "featureType": "administrative",
                            "elementType": "labels.text",
                            "stylers": [{"color": "#939393"}]
                        },
                        //urban land color is next line
                        {"featureType": "landscape", "stylers": [{"color": "#cccccc"}]},
                        {
                            "featureType": "landscape.man_made",
                            "elementType": "geometry.stroke",
                            "stylers": [{"color": "#334e87"}]
                        },
                        //main land color is the next line
                        {"featureType": "landscape.natural", "stylers": [{"color": "#d3e9d5"}]},
                        {"featureType": "poi", "stylers": [{"visibility": "off"}]},
                        {"featureType": "poi", "elementType": "geometry", "stylers": [{"color": "#283d6a"}]},
                        {"featureType": "poi", "elementType": "labels.text.fill", "stylers": [{"color": "#6f9ba5"}]},
                        {"featureType": "poi", "elementType": "labels.text.stroke", "stylers": [{"color": "#1d2c4d"}]},
                        //park areas color is next line
                        {"featureType": "poi.park", "stylers": [{"color": "#b8ddc3"}, {"visibility": "simplified"}]},
                        {"featureType": "poi.park", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {"featureType": "poi.park", "elementType": "labels.icon", "stylers": [{"visibility": "off"}]},
                        //road color is the next line
                        {"featureType": "road", "elementType": "geometry", "stylers": [{"color": "#f2f2f2"}]},
                        {"featureType": "road", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {"featureType": "road", "elementType": "labels.text.fill", "stylers": [{"color": "#4e6d70"}]},
                        {"featureType": "road", "elementType": "labels.text.stroke", "stylers": [{"color": "#f2f2f2"}]},
                        {"featureType": "road.arterial", "stylers": [{"visibility": "simplified"}]},
                        {
                            "featureType": "road.arterial",
                            "elementType": "geometry",
                            "stylers": [{"visibility": "simplified"}]
                        },
                        {"featureType": "road.arterial", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {"featureType": "road.highway", "stylers": [{"visibility": "simplified"}]},
                        {"featureType": "road.highway", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {
                            "featureType": "road.highway",
                            "elementType": "labels.text.fill",
                            "stylers": [{"color": "#4e6d70"}]
                        },
                        {
                            "featureType": "road.highway",
                            "elementType": "labels.text.stroke",
                            "stylers": [{"color": "#f2f2f2"}]
                        },
                        //transit lines and land area polygons are the next line
                        {"featureType": "transit", "stylers": [{"color": "#b2b2b2"}]},
                        {"featureType": "transit", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {
                            "featureType": "transit",
                            "elementType": "labels.text.fill",
                            "stylers": [{"color": "#98d2b2"}]
                        },
                        {
                            "featureType": "transit",
                            "elementType": "labels.text.stroke",
                            "stylers": [{"color": "#F2F2F2"}]
                        },
                        {"featureType": "water", "stylers": [{"color": "#b6d5e3"}]},
                        {"featureType": "water", "elementType": "labels.text.fill", "stylers": [{"color": "#4e6d70"}]}]
                });
                google.maps.Polygon.prototype.Contains = function (point) {
                    var crossings = 0,
                        path = this.getPath();

                    // for each edge
                    for (var i = 0; i < path.getLength(); i++) {
                        var a = path.getAt(i),
                            j = i + 1;
                        if (j >= path.getLength()) {
                            j = 0;
                        }
                        var b = path.getAt(j);
                        if (rayCrossesSegment(point, a, b)) {
                            crossings++;
                        }
                    }

                    // odd number of crossings?
                    return (crossings % 2 == 1);

                    function rayCrossesSegment(point, a, b) {
                        var px = point.lng(),
                            py = point.lat(),
                            ax = a.lng(),
                            ay = a.lat(),
                            bx = b.lng(),
                            by = b.lat();
                        if (ay > by) {
                            ax = b.lng();
                            ay = b.lat();
                            bx = a.lng();
                            by = a.lat();
                        }
                        // alter longitude to cater for 180 degree crossings
                        if (px < 0) {
                            px += 360;
                        }
                        if (ax < 0) {
                            ax += 360;
                        }
                        if (bx < 0) {
                            bx += 360;
                        }

                        if (py == ay || py == by) py += 0.00000001;
                        if ((py > by || py < ay) || (px > Math.max(ax, bx))) return false;
                        if (px < Math.min(ax, bx)) return true;

                        var red = (ax != bx) ? ((by - ay) / (bx - ax)) : Infinity;
                        var blue = (ax != px) ? ((py - ay) / (px - ax)) : Infinity;
                        return (blue >= red);

                    }

                };
                var drawingManager = new google.maps.drawing.DrawingManager({
                    drawingMode: google.maps.drawing.OverlayType.POLYGON,
                    drawingControl: true,
                    drawingControlOptions: {
                        position: google.maps.ControlPosition.TOP_CENTER,
                        drawingModes: ["polygon"]
                    },
                    markerOptions: {icon: "https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png"},
                    circleOptions: {
                        fillColor: "#ffff00",
                        fillOpacity: 1,
                        strokeWeight: 5,
                        clickable: false,
                        editable: true,
                        zIndex: 1
                    }
                });
                drawingManager.setMap(map);
                google.maps.event.addListener(drawingManager, "polygoncomplete", function (polygon) {
                        let site = {
                            polygon: polygon.getPath().getArray(),
                            Polygon: polygon,
                            coordinates: [],
                            markers: [],
                            habitat: {},
                            siteSpecies: new Set(),
                            taxa: new Set(),
                            minX: polygon.getPath().getArray()[0].lng() + 180,
                            minY: polygon.getPath().getArray()[0].lat() * -1 + 90,
                            maxX: polygon.getPath().getArray()[0].lng() + 180,
                            maxY: polygon.getPath().getArray()[0].lat() * -1 + 90
                        }
                        for (let i = 0; i < site.polygon.length; i++) {
                            site.coordinates.push({lat: site.polygon[i].lat(), lng: site.polygon[i].lng()})
                            if(site.polygon[i].lat() * -1 + 90 < site.minY) {
                                site.minY = site.polygon[i].lat() * -1 + 90;
                            }
                            if(site.polygon[i].lat() * -1 + 90 > site.maxY) {
                                site.maxY = site.polygon[i].lat() * -1 + 90;
                            }
                            if (site.polygon[i].lng() + 180 < site.minX) {
                                site.minX = site.polygon[i].lng() + 180;
                            }
                            if (site.polygon[i].lng() + 180 > site.maxX) {
                                site.maxX = site.polygon[i].lng() + 180;
                            }
                        }
                        addSiteToUi(site);
                        sites.push(site)
                });
            }
            function addSiteToUi(site) {
                let siteElement = document.createElement("DIV");
                siteElement.className = "newSite";
                let siteSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                siteSvg.setAttribute("height", "30px");
                siteSvg.setAttribute("width", "60px");
                let viewBox = site.minX + " " + site.minY + " " + (site.maxX - site.minX) + " " + (site.maxY - site.minY);
                siteSvg.setAttribute("viewBox", viewBox);
                let sitePolygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");

                let points = "";
                for(let i = 0; i < site.coordinates.length; i++) {
                    points += (site.coordinates[i].lng + 180) + " " + (site.coordinates[i].lat * -1 + 90);
                    if(i < site.coordinates.length - 1) {
                        points += " ";
                    }
                }
                sitePolygon.setAttribute("points", points);

                siteSvg.appendChild(sitePolygon);
                siteElement.appendChild(siteSvg);

                let siteData = document.createElement("DIV");
                siteData.setAttribute("style", "display: flex; flex-direction:column;");
                let siteName = document.createElement("DIV");
                siteData.appendChild(siteName);
                siteName.innerText = "Site Name";
                let siteInput = document.createElement("INPUT");
                siteInput.className = "siteName";
                siteInput.addEventListener("input", function () {
                    site.name = this.value;
                });
                siteData.appendChild(siteInput);
                let siteHabitat = document.createElement("DIV");
                siteData.appendChild(siteHabitat);
                siteHabitat.innerText = "Habitat Select";
                let siteHabitatSelector = document.createElement("SELECT");
                siteHabitatSelector.className = "siteHabitatSelector";
                for(let i = 0; i < habitats.length ; i++) {
                    let option = document.createElement("OPTION")
                    option.appendChild(document.createTextNode(habitats[i]));
                    siteHabitatSelector.appendChild(option);
                }

                siteData.appendChild(siteHabitatSelector);

                siteHabitatSelector.onchange = function () {
                    site.habitat.name = this.value;
                };

                siteElement.appendChild(siteData);
                site.siteHatbitatSelector = siteHabitatSelector;

                document.getElementById("habitatsPanel").appendChild(siteElement);
            }

            function addHabitat() {
                let habitatNameElement = document.getElementById("habitatNameId");
                let habitatName = habitatNameElement.value;
                let newHabitat = {
                    title: habitatName,
                    field: habitatName,
                    width: 90,
                    align: "center",
                    formatter: "tickCross",
                    sorter: "boolean",
                    editor: true
                }
                habitatData.push(newHabitat);
                columns.push(newHabitat);
                table.setColumns(columns);
                table.redraw(true);

                addHabitatData(habitatName);

                habitatNameElement.value = "";
            }

            function addHabitatData(habitatName) {
                habitats.push(habitatName);
                let newHabitatLabel = document.createElement("DIV");
                newHabitatLabel.textContent = habitatName
                document.getElementsByClassName("habitat")[0].appendChild(newHabitatLabel);
                for (let site in sites) {
                    let option = document.createElement("OPTION");
                    option.appendChild(document.createTextNode(habitatName));
                    sites[site].siteHatbitatSelector.appendChild(option);
                }

                let button = document.createElement("button");
                button.innerHTML = habitatName;
                button.addEventListener("click", function () {
                    verifyTable(this);
                });
                document.getElementById("verifyButtons").appendChild(button);

                let surrogateSpeciesByHabitatChartButton = document.createElement("button");
                surrogateSpeciesByHabitatChartButton.innerHTML = habitatName;
                surrogateSpeciesByHabitatChartButton.addEventListener("click", function () {
                    surrogateSpeciesByHabitatChart(this);
                });
                document.getElementById("surrogateSpeciesByHabitatChartButtons").appendChild(surrogateSpeciesByHabitatChartButton);

                let surrogateSpeciesByHabitatButton = document.createElement("button");
                surrogateSpeciesByHabitatButton.innerHTML = habitatName;
                surrogateSpeciesByHabitatButton.addEventListener("click", function () {
                    surrogateSpeciesByHabitatTable(this);
                });
                document.getElementById("surrogateSpeciesByHabitatButtons").appendChild(surrogateSpeciesByHabitatButton);
            }

            function addTaxon() {
                taxonNameElement = document.getElementById("taxonNameId");
                taxa.push(taxonNameElement.value);
                columns[1].editorParams[taxonNameElement.value] = taxonNameElement.value;
                table.setColumns(columns);
                table.redraw(true);
                newTaxonLabel = document.createElement("DIV");
                newTaxonLabel.textContent = taxonNameElement.value;
                document.getElementsByClassName("taxon")[0].appendChild(newTaxonLabel);

                // let taxonButton = document.createElement("button");
                // taxonButton.innerHTML = taxonNameElement.value;
                // taxonButton.addEventListener("click", function () {
                //     console.log(taxonNameElement.value);
                // });
                // document.getElementById("taxaButtons").appendChild(taxonButton);

                taxonNameElement.value = "";
            }

            function addSpecies() {
                table.addRow(); //it is annoying AF to add every taxa to these, set the default to "sought"
            }

            function save() {
                let tableData = "";
                if(table != null)
                    tableData = table.getData();
                let saveData = {
                    "id": id,
                    "name": document.getElementById("projectName").value,
                    "description": document.getElementById("projectDescription").value,
                    "taxa": taxa,
                    "habitatData": habitatData,
                    "sites": sites, //This should contain all of the markers, observations, polygons, and habitats
                    markers, //All observations
                    //todo: we'll probably want to store the iNaturalist urls at some point
                    tableData, //This contains the columns and the rows which the user should have also overridden if needed.
                    "startDate": startDate,
                    "endDate": endDate,
                    "timeFrame": timeFrame
                }

                httpPost("/createUserDataFromJSON", setId, saveData);
            }

            function setId(response) {
                id = response;
            }

            processRequest = function () {
                getINaturalistData().then(placeMarkers);
            }

            getINaturalistData = function () {
                return new Promise(function (resolve) {
                    iNaturalistProjectId = document.getElementById("input").value;
                    iNaturalistProjectId = encodeURIComponent(iNaturalistProjectId);
                    document.getElementById("input").value = "";

                    let xhr = new XMLHttpRequest();

                    xhr.onreadystatechange = function () {
                        if (xhr.readyState == 3) {

                        } else if (xhr.readyState == 4 && xhr.status == 200) {
                            resolve(JSON.parse(xhr.responseText));
                        }
                    };

                    xhr.open("GET", "https://inaturalist.org/observations/project/" + iNaturalistProjectId + ".json", true);
                    xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
                    xhr.send();
                });
            }

            placeMarkers = function (observations) {
                greyImage = {
                    url: "/images/marker_0_grey_39x59.png",
                    scaledSize: new google.maps.Size(20, 30)
                };
                for (observation in observations) {
                    let position = {
                        lat: parseFloat(observations[observation].latitude),
                        lng: parseFloat(observations[observation].longitude)
                    };
                    let marker = new google.maps.Marker({
                        position: position,
                        map: map,
                        icon: greyImage
                    });
                    marker.observation = observations[observation];
                    marker.observedOn = new Date(observations[observation].observed_on);
                    marker.taxon = observations[observation].iconic_taxon_name;
                    marker.species = observations[observation].species_guess;
                    marker.presence = 1;
                    if (!speciesSet.has(marker.species) && marker.species != null && marker.species.length != 0) {
                        table.addRow({species: marker.species});
                    }
                    table.redraw(true);
                    speciesSet.add(marker.species);
                    markers.push(marker);
                }
                updateMap();
            }

            updateMap = function () {
                let minLat, maxLat, minLng, maxLng;
                for (i = 0; i < markers.length; i++) {
                    if (minLat == null || markers[i].getPosition().lat() < minLat)
                        minLat = markers[i].getPosition().lat();
                    if (maxLat == null || markers[i].getPosition().lat() > maxLat)
                        maxLat = markers[i].getPosition().lat();
                    if (minLng == null || markers[i].getPosition().lng() < minLng)
                        minLng = markers[i].getPosition().lng();
                    if (maxLng == null || markers[i].getPosition().lng() > maxLng)
                        maxLng = markers[i].getPosition().lng();
                }

                let rectangle = new google.maps.Rectangle({
                    strokeColor: "#FFFFFF",
                    strokeOpacity: 0.0,
                    strokeWeight: 2,
                    fillColor: "#FFFFFF",
                    fillOpacity: 0.0,
                    map: map,
                    bounds: {
                        north: maxLat,
                        south: minLat,
                        east: maxLng,
                        west: minLng
                    }
                });

                map.fitBounds(rectangle.getBounds());

                map.setCenter({lat: ((maxLat - minLat) / 2 + minLat), lng: ((maxLng - minLng) / 2 + minLng)});
                map.setZoom(17); //todo: set this by bounds
            }

            mapHabitatsToSites = function () {
                let habitatSelectors = document.getElementsByClassName("siteHabitatSelector");
                let siteNames = document.getElementsByClassName("siteName");
                for (let i = 0; i < habitatSelectors.length; i++) {
                    sites[i].habitat.name = habitatSelectors[i].options[habitatSelectors[i].selectedIndex].value;
                    sites[i].name = siteNames[i].value;
                }
            }

            chartSites = function () {
                mapHabitatsToSites();
                // if(true) {
                    for (let i = 0; i < markers.length; i++) {
                        for (let k = 0; k < sites.length; k++) {
                            if (sites[k].Polygon.Contains(markers[i].getPosition())) {
                                sites[k].markers.push(markers[i]);
                                //todo: see UBIF-0015
                                // break;
                            }
                        }
                    }
                // } else {
                //     let mySiteSpecies = new Set();
                //     mySiteSpecies.add("Grass");
                //     mySiteSpecies.add("Tree");
                //     sites = [
                //         {
                //             name: "site 1",
                //             markers:[
                //                 {
                //                     species:"Grass",
                //                     observedOn: new Date("2019-01-01")
                //                 },
                //                 {
                //                     species: "Tree",
                //                     observedOn: new Date("2019-02-02")
                //                 }
                //                 ],
                //             habitat: "a",
                //             taxa: "Plants",
                //             siteSpecies: mySiteSpecies
                //         },
                //         {
                //             name: "site 2",
                //             markers: [
                //                 {
                //                     species: "Grass",
                //                     observedOn: new Date("2019-01-01")
                //                 },
                //                 {
                //                     species: "Tree",
                //                     observedOn: new Date("2019-02-02")
                //                 }
                //             ],
                //             habitat: "a",
                //             taxa: "Plants",
                //             siteSpecies: mySiteSpecies
                //         },
                //         {
                //             name: "site 3",
                //             markers: [
                //                 {
                //                     species: "Grass",
                //                     observedOn: new Date("2019-01-01")
                //                 },
                //                 {
                //                     species: "Tree",
                //                     observedOn: new Date("2019-02-02")
                //                 }
                //             ],
                //             habitat: "a",
                //             taxa: "Plants",
                //             siteSpecies: mySiteSpecies
                //         }
                //     ]
                // }

                timeSlices = getTimeSlices(startDate, endDate, timeFrame);

                observationsPerSiteByTaxon(taxa);
                observationsOfSurrogateSpeciesInAllHabitatsOverTime(taxa, timeSlices);
            }

            function getTimeSlices(start, end, frame) {
                let result = [];
                if(start == null) {
                    return result;
                }
                let nextDate = new Date(start);
                if(frame == "month") {
                    while(nextDate <= end) {
                        result.push(new Date(nextDate));
                        nextDate = new Date(nextDate.setMonth(nextDate.getMonth() + 1));
                    }
                } else {
                    while (nextDate <= end) {
                        result.push(nextDate);
                        nextDate = new Date(nextDate.setFullYear(nextDate.getFullYear() + 1));
                    }
                }

                return result;
            }

            observationsPerSiteByTaxon = function(taxa) {
                clearPriorChartIfAny("observationsPerSiteByTaxon");

                const svgWidth = 500;
                const svgHeight = 300;
                const strokeWidth = 0;
                const barWidth = 20;
                const headerHeight = 20; //we need this so that 100% at the top isn't cut off to look like iuu,o
                const footerHeight = 20;
                const leftAxisMargin = 20;
                const leftAxisExtraMargin = leftAxisMargin + 24;
                const barZoneWidth = svgWidth - leftAxisExtraMargin;
                const barPadding = barZoneWidth / taxa.length / 2;

                let heightFactor = svgHeight - footerHeight - headerHeight;

                let heights = [];

                let svg = d3.select('#observationsPerSiteByTaxon')
                    .attr("width", svgWidth)
                    .attr("height", svgHeight)
                    .attr("class", "bar-chart");

                svg.selectAll("rect")
                    .data(taxa)
                    .enter()
                    .append("rect")
                    .attr("height", function (d) {
                        let incrimentalResults = [];
                        for (let i = 0; i < sites.length; i++) {
                            let numerator = 0;
                            let denominator = 0;
                            for (let k = 0; k < sites[i].markers.length; k++) {
                                if(d == speciesTaxaMap.get(sites[i].markers[k].species)) {
                                    numerator++;
                                    break;
                                }
                            }
                            sites[i].siteSpecies.forEach(function (species) {
                                if (d == speciesTaxaMap.get(species))
                                    denominator++;
                            });
                            if(denominator !== 0) {
                                incrimentalResults.push(numerator / denominator);
                            }
                        }
                        let height;
                        if(incrimentalResults.length === 0)
                            height = 0;
                        else
                            height = incrimentalResults.reduce(function(a,b){return a+b;}) / incrimentalResults.length;

                        height = height * heightFactor;
                        heights.push(height);
                        return height;
                    })
                    .style("stroke", "white")
                    .style("fill", "grey")
                    .style("stroke-width", strokeWidth)
                    .attr("width", barWidth)
                    .attr("transform", function (d, i) {
                        let translate = [i * barZoneWidth / taxa.length + leftAxisExtraMargin + barPadding, footerHeight + heightFactor - heights[i]];
                        return "translate(" + translate + ")";
                    });

                svg.selectAll("text")
                    .data(taxa)
                    .enter()
                    .append("text")
                    .attr("class", "chartLabel")
                    .style("text-anchor", "middle")
                    .attr("fill", "black")
                    .attr("width", svgWidth / taxa.length)
                    .attr("transform", function (d, i) {
                        let translate = [i * (barZoneWidth / taxa.length) + (barZoneWidth / taxa.length - strokeWidth) / 2 + leftAxisExtraMargin, svgHeight];
                        return "translate(" + translate + ")";
                    })
                    .text(function (d) {
                        return d;
                    });

                let yScale = d3.scaleLinear()
                    .domain([1, 0])
                    .range([footerHeight, svgHeight - headerHeight]);

                const formatPercent = d3.format(".0%");

                let yAxis = d3.axisLeft()
                    .scale(yScale)
                    .tickFormat(formatPercent)
                    .tickSize(svgWidth - leftAxisMargin, 0, 0);

                svg.append("g")
                    .attr("transform", "translate(" + (svgWidth + leftAxisMargin) + ", " + 0 + ")")
                    .call(yAxis);
            }

            observationsOfSurrogateSpeciesInAllHabitatsOverTime = function (taxa) {
                clearPriorChartIfAny("observationsOfSurrogateSpeciesInAllHabitatsOverTime");

                const svgWidth = 500;
                const svgHeight = 300;
                const strokeWidth = 0;
                const barWidth = 20;
                const headerHeight = 20; //we need this so that 100% at the top isn't cut off to look like iuu,o
                const footerHeight = 20;
                const leftAxisMargin = 20;
                const leftAxisExtraMargin = leftAxisMargin + 24;
                const barZoneWidth = svgWidth - leftAxisExtraMargin;
                const barPadding = 10;
                const textPadding = barPadding + 4;
                const timeSliceTextVerticalSpace = 10;

                let heightFactor = svgHeight - footerHeight - headerHeight;

                let svg = d3.select('#observationsOfSurrogateSpeciesInAllHabitatsOverTime')
                    .attr("width", svgWidth)
                    .attr("height", svgHeight)
                    .attr("class", "bar-chart");

                for(let timeSliceIndex = 0; timeSliceIndex < timeSlices.length - 1; timeSliceIndex++) {
                    let heights = [];
                    svg.selectAll("rect" + timeSliceIndex)
                        .data(taxa)
                        .enter()
                        .append("rect")
                        .attr("height", function (d) {
                            let incrimentalResults = [];
                            for (let i = 0; i < sites.length; i++) {
                                let numerator = 0;
                                let denominator = 0;
                                for (let k = 0; k < sites[i].markers.length; k++) {
                                    if (sites[i].markers[k].observedOn >= timeSlices[timeSliceIndex] && sites[i].markers[k].observedOn < timeSlices[timeSliceIndex + 1] && d == speciesTaxaMap.get(sites[i].markers[k].species)) {
                                        numerator++;
                                        break;
                                    }
                                }
                                sites[i].siteSpecies.forEach(function (species) {
                                    if (d == speciesTaxaMap.get(species))
                                        denominator++;
                                });
                                if (denominator !== 0) {
                                    incrimentalResults.push(numerator / denominator);
                                }
                            }
                            let height;
                            if (incrimentalResults.length === 0)
                                height = 0;
                            else
                                height = incrimentalResults.reduce(function (a, b) {
                                    return a + b;
                                }) / incrimentalResults.length;

                            height = height * heightFactor;
                            heights.push(height);
                            return height;
                        })
                        .style("stroke", "white")
                        .style("fill", "grey")
                        .style("stroke-width", strokeWidth)
                        .attr("width", barWidth)
                        .attr("transform", function (d, i) {
                            let translate = [timeSliceIndex * barZoneWidth / taxa.length / (timeSlices.length - 1) + i * barZoneWidth / taxa.length + leftAxisExtraMargin + barPadding, svgHeight - footerHeight - heights[i]];
                            return "translate(" + translate + ")";
                        });

                    svg.selectAll("textOfTimeSlice" + timeSliceIndex)
                        .data(taxa)
                        .enter()
                        .append("text")
                        .attr("class", "chartLabel")
                        .style("text-anchor", "middle")
                        .style("font-size", "8px")
                        .attr("fill", "black")
                        .attr("width", svgWidth / timeSlices.length)
                        .attr("transform", function (d, i) {
                            let translate = [timeSliceIndex * barZoneWidth / taxa.length / (timeSlices.length - 1) + i * barZoneWidth / taxa.length + leftAxisExtraMargin + textPadding, svgHeight - timeSliceTextVerticalSpace];
                            return "translate(" + translate + ")";
                        })
                        .text(function (d) {
                            if (timeFrame == "month") {
                                return monthNames[timeSlices[timeSliceIndex].getMonth()];
                            } else
                                return timeSlices[timeSliceIndex].getFullYear();
                        });
                }

                svg.selectAll("textOfTaxaNames")
                    .data(taxa)
                    .enter()
                    .append("text")
                    .attr("class", "chartLabel")
                    .style("text-anchor", "middle")
                    .attr("fill", "black")
                    .attr("width", svgWidth / taxa.length)
                    .attr("transform", function (d, i) {
                        let translate = [i * (barZoneWidth / taxa.length) + (barZoneWidth / taxa.length - strokeWidth) / 2 + leftAxisExtraMargin, svgHeight];
                        return "translate(" + translate + ")";
                    })
                    .text(function (d) {
                        return d;
                    });

                let yScale = d3.scaleLinear()
                    .domain([1, 0])
                    .range([footerHeight, svgHeight - headerHeight]);

                const formatPercent = d3.format(".0%");

                let yAxis = d3.axisLeft()
                    .scale(yScale)
                    .tickFormat(formatPercent)
                    .tickSize(svgWidth - leftAxisMargin, 0, 0);

                svg.append("g")
                    .attr("transform", "translate(" + (svgWidth + leftAxisMargin) + ", " + 0 + ")")
                    .call(yAxis);
            }

            surrogateSpeciesByHabitatChart = function(habitatButton) {
                clearPriorChartIfAny("surrogateSpeciesByHabitatChart");

                const svgWidth = 500;
                const svgHeight = 300;
                const strokeWidth = 0;
                const barWidth = 20;
                const headerHeight = 20; //we need this so that 100% at the top isn't cut off to look like iuu,o
                const footerHeight = 20;
                const leftAxisMargin = 20;
                const leftAxisExtraMargin = leftAxisMargin + 24;
                const barZoneWidth = svgWidth - leftAxisExtraMargin;
                const barPadding = barZoneWidth / taxa.length / 2;

                let heightFactor = svgHeight - footerHeight - headerHeight;

                let heights = [];

                let svg = d3.select('#surrogateSpeciesByHabitatChart')
                    .attr("width", svgWidth)
                    .attr("height", svgHeight)
                    .attr("class", "bar-chart");

                svg.selectAll("rect")
                    .data(taxa)
                    .enter()
                    .append("rect")
                    .attr("height", function (d) {
                        let incrimentalResults = [];
                        for (let i = 0; i < sites.length; i++) {
                            if(sites[i].habitat.name != habitatButton.innerHTML){
                                continue;
                            }
                            let numerator = 0;
                            let denominator = 0;
                            for (let k = 0; k < sites[i].markers.length; k++) {
                                if (d == speciesTaxaMap.get(sites[i].markers[k].species)) {
                                    numerator++;
                                    break;
                                }
                            }
                            sites[i].siteSpecies.forEach(function (species) {
                                if (d == speciesTaxaMap.get(species))
                                    denominator++;
                            });
                            if (denominator !== 0) {
                                incrimentalResults.push(numerator / denominator);
                            }
                        }
                        let height;
                        if (incrimentalResults.length === 0)
                            height = 0;
                        else
                            height = incrimentalResults.reduce(function (a, b) {
                                return a + b;
                            }) / incrimentalResults.length;

                        height = height * heightFactor;
                        heights.push(height);
                        return height;
                    })
                    .style("stroke", "white")
                    .style("fill", "grey")
                    .style("stroke-width", strokeWidth)
                    .attr("width", barWidth)
                    .attr("transform", function (d, i) {
                        let translate = [i * barZoneWidth / taxa.length + leftAxisExtraMargin + barPadding, footerHeight + heightFactor - heights[i]];
                        return "translate(" + translate + ")";
                    });

                svg.selectAll("text")
                    .data(taxa)
                    .enter()
                    .append("text")
                    .attr("class", "chartLabel")
                    .style("text-anchor", "middle")
                    .attr("fill", "black")
                    .attr("width", svgWidth / taxa.length)
                    .attr("transform", function (d, i) {
                        let translate = [i * (barZoneWidth / taxa.length) + (barZoneWidth / taxa.length - strokeWidth) / 2 + leftAxisExtraMargin, svgHeight];
                        return "translate(" + translate + ")";
                    })
                    .text(function (d) {
                        return d;
                    });

                let yScale = d3.scaleLinear()
                    .domain([1, 0])
                    .range([footerHeight, svgHeight - headerHeight]);

                const formatPercent = d3.format(".0%");

                let yAxis = d3.axisLeft()
                    .scale(yScale)
                    .tickFormat(formatPercent)
                    .tickSize(svgWidth - leftAxisMargin, 0, 0);

                svg.append("g")
                    .attr("transform", "translate(" + (svgWidth + leftAxisMargin) + ", " + 0 + ")")
                    .call(yAxis);
            }

            // chart = function (sites) {
            //     // clearPriorChartIfAny();
            //     if(startDate == null) {
            //         startDate = new Date("1900-01-01");
            //     }
            //
            //     const svgWidth = 500;
            //     const svgHeight = 300;
            //     const strokeWidth = 5;
            //     const barWidth = 20;
            //     const footerHeight = 10;
            //     const headerHeight = 5; //we need this so that 100% at the top isn't cut off to look like iuu,o
            //     const leftAxisMargin = 20;
            //     const leftAxisExtraMargin = leftAxisMargin + 24;
            //     const barZoneWidth = svgWidth - leftAxisExtraMargin;
            //     const barPadding = barZoneWidth / sites.length / 2;
            //
            //     let svg = d3.select('.chart') //there's now multiple svgs in the dom, so it's selecting the first one it finds in dom order...
            //         .attr("width", svgWidth)
            //         .attr("height", svgHeight)
            //         .attr("class", "bar-chart");
            //
            //     svg.selectAll("rect")
            //         .data(sites)
            //         .enter()
            //         .append("rect")
            //         .attr("height", function (d) {
            //             let speciesInPolygon = new Set();
            //             let presence = 0;
            //             for (marker in d.markers) {
            //                 if (!speciesInPolygon.has(d.markers[marker].species) && d.siteSpecies.has(d.markers[marker].species) && d.markers[marker].observedOn < endDate && d.markers[marker].observedOn > startDate) { //please make me a function
            //                     presence += 1;
            //                 }
            //                 speciesInPolygon.add(d.markers[marker].species);
            //             }
            //             if (d.siteSpecies.size != 0) {
            //                 presence = svgHeight * (presence / d.siteSpecies.size);
            //             }
            //             d.presence = presence;
            //             return presence;
            //         })
            //         .style("stroke", "white")
            //         .style("fill", "grey")
            //         .style("stroke-width", strokeWidth)
            //         // .attr("y", function (d) {
            //         //     return svgHeight - d.presence;
            //         // })
            //         .attr("width", barWidth)
            //         .attr("transform", function (d, i) {
            //             let translate = [i * barZoneWidth / sites.length + leftAxisExtraMargin + barPadding, 0];
            //             return "translate(" + translate + ")";
            //         });
            //
            //     svg.selectAll("text")
            //         .data(sites)
            //         .enter()
            //         .append("text")
            //         .attr("class", "chartLabel")
            //         .style("text-anchor", "middle")
            //         .attr("fill", "black")
            //         .attr("width", svgWidth / sites.length)
            //         .attr("transform", function (d, i) {
            //             let translate = [i * (barZoneWidth / sites.length) + (barZoneWidth / sites.length - strokeWidth) / 2 + leftAxisExtraMargin, svgHeight - 10];
            //             return "translate(" + translate + ")";
            //         })
            //         .text(function (d) {
            //             return d.habitat.name;
            //         });
            //
            //     let yScale = d3.scaleLinear()
            //         .domain([1, 0])
            //         .range([footerHeight, svgHeight - footerHeight - headerHeight]);
            //
            //     const formatPercent = d3.format(".0%");
            //
            //     let yAxis = d3.axisLeft()
            //         .scale(yScale)
            //         .tickFormat(formatPercent)
            //         .tickSize(svgWidth - leftAxisMargin, 0, 0);
            //
            //     svg.append("g")
            //         .attr("transform", "translate(" + (svgWidth + leftAxisMargin) + ", " + footerHeight + ")")
            //         .call(yAxis);
            // }

            function clearPriorChartIfAny(oldChartId) {
                let oldChart = document.getElementById(oldChartId);
                if (oldChart != null) {
                    while (oldChart.firstChild) {
                        oldChart.removeChild(oldChart.firstChild);
                    }
                    oldChart.setAttribute("class", "chart");
                }
            }

            function hide(element) {
                element.classList.add("hidden");
            }

            function displayInfoButton0() {
                document.getElementById("infoButton0").classList.remove("hidden");
            }

            function displayInfoButton2() {
                document.getElementById("infoButton2").classList.remove("hidden");
            }

            function displayInfoButton4() {
                document.getElementById("infoButton4").classList.remove("hidden");
            }

            function displayInfoButton6() {
                document.getElementById("infoButton6").classList.remove("hidden");
            }

            function togglePanelOpenOrClosed(tab, panelId) {
                var panel = document.getElementById(panelId);
                var status = panel.classList.contains("hide");
                if (status) {
                    panel.classList.remove("hide");
                    tab.classList.add("active");
                } else {
                    panel.classList.add("hide");
                    tab.classList.remove("active");
                }
            }

body
    +header(true)

    div(style="padding-top:40px;")

            div(style="margin:auto; display:flex; flex-direction:column; align-items:center;")
                +stickyInfoTab("UBIF Track 2 Project Setup", "infant1", "#07456b", false, "stickyFirst")
                div(id="infant1" class="mapInfoContent hide")
                    div(style="margin:auto; max-width:400px; display:flex; flex-direction:column; align-items:center;")
                        div
                            //h1(class="bold") UBIF Track 2 Project Setup
                            div(class="flex spaceBelow") In the Urban Biodiversity Inventory Framework (UBIF), Track 2 system, cities indicate surrogate species they would like to track for each habitat type in their city.  Here you will set up the parameters of your project.
                                img(src="/images/infoIcon.svg" style="height:20px; width:20px; align-self:flex-end;" onMouseOver="this.src='/images/infoIconHover.svg'" onMouseOut="this.src='/images/infoIcon.svg'" onClick="displayInfoButton0()")
                                div(id="infoButton0" class="hidden popup" onclick="hide(document.getElementById('infoButton0'))")
                                    div Purposefully collecting data to assess urban biodiversity provides cities the ability to generate summary statistics and track changes over time in a more measurable way than is provided by conducting Track 1 data collection only. Track 2 employs presence/absence monitoring of species as a way to track and assess urban biodiversity. Recording the presence of species in Track 1 is valuable information, but knowing where species are not is also essential to assist in decision making for restoration action or other management decisions that can be applied to improve habitat quality and/or quantity.
                                    div Two major decisions must be made before presence/absence monitoring can begin: Which species will be surveyed for, and what locations will be surveyed. With unlimited resources, a city could attempt to exhaustively record all species of all taxa at every possible location. However, given normal limitations, this is an unattainable goal. In order to best use limited resources, a surrogate species approach (Caro 2010) and recommendations for selecting reference sites within as well as outside of the city, are employed for Track 2 and Track 3.

                            div(style="margin-bottom:20px;") <b>Step 1. Name your project</b>
                                div Choose a name to encompass the entire UBIF Track 2 initiative for your city through time as long as it maintains the same overall structure (such as taxon). Only small changes to the project can be accommodated without starting a new project.
                                div(class="bold blue smallSpaceAbove") Enter Project Name
                                input(id="projectName")
                                div(class="bold blue smallSpaceAbove") Enter Project Description
                                textarea(id="projectDescription" rows="3" class="fullWidth")

                            div(style="margin-bottom:20px;") <b>Step 2. Indicate Taxonomic Groups</b>
                                div(style="display:flex;") Surrogate species must be indicated in at least five different taxonomic groups. The first three of these groups are birds, plants, and invertebrate pollinators. The remaining two are customizable by city. Indicate those here.
                                    img(src="/images/infoIcon.svg" style="height:20px; width:20px; align-self:flex-end;" onMouseOver="this.src='/images/infoIconHover.svg'" onMouseOut="this.src='/images/infoIcon.svg'" onClick="displayInfoButton2()")
                                    div(id="infoButton2" class="hidden popup" onclick="hide(document.getElementById('infoButton2'))")
                                        div As cities consider surrogate species selections, the first criteria is to select species from diverse taxa groups that are typically found in or are obligate to a given habitat type of good quality and are neither very rare nor overly common.  The plant, bird and invertebrate pollinator taxa groups are universal throughout cities utilizing the UBIF. However, additional taxa groups are chosen at the discretion of the cities, with at least two additional taxa groups recommended.

                                div(class="flex column smallSpaceAbove")
                                    div(class="bold blue") Enter Taxa
                                    div(class="flex")
                                        input(id="taxonNameId")
                                        button(onclick="addTaxon()") add taxon
                                    div(class="taxon boxedChildren smallSpaceAbove")

                            div(style="margin-bottom:20px;") <b>Step 3. Indicate your habitats of interest.</b>
                                div Indicate the various habitats that you will be tracking in this project. The type and number of habitats of interest should be based on known native habitats found currently or historically within the city and is completely up to the individual city’s discretion. Note that the surrogate species will be the same across each habitat (each habitat will often have multiple sites known as “place”). Some examples include: prairie, wetland, freshwater, douglas fir forest, brownfields.
                                div(class="flex column smallSpaceAbove")
                                    div(class="bold blue") Enter Habitats
                                    div(class="flex")
                                        input(id="habitatNameId")
                                        button(onclick="addHabitat()") add habitat
                                    div(class="habitat boxedChildren smallSpaceAbove")

                            div(class="spaceBelow") <b>Step 4. Indicate places of interest.</b>
                             div(class="flex") Draw a polygon on the map below for each place (such as a park) of interest. Name each place accordingly. Note that each place can only have one habitat type, so it may be appropriate to divide certain parks into multiple places if they cover more than one habitat type. The polygon shapes will be used to pull data from species observations databases in a later step. For each habitat type, you may indicate one place to serve as a reference monitoring site. Reference sites represent desirable conditions for other places of the same habitat type and provide a yardstick to measure the other places of the same habitat against.
                                 img(src="/images/infoIcon.svg" style="height:20px; width:20px; align-self:flex-end;" onMouseOver="this.src='/images/infoIconHover.svg'" onMouseOut="this.src='/images/infoIcon.svg'" onClick="displayInfoButton4()")
                                 div(id="infoButton4" class="hidden popup" onclick="hide(document.getElementById('infoButton4'))")
                                        div(class="spaceBelow") From large protected natural areas to small vegetated parking strips, habitat quality and quantity within cities varies greatly. The best utilization of the UBIF, as a means to attain a comprehensive analysis of biodiversity in the city, requires that a diversity of sites be selected. In this way, care should be taken to select sites with a range of perceived quality and avoid the temptation to only select the “best” or “favorite” sites within the city.
                                        div(class="spaceBelow") Collecting biodiversity data exclusively within the city allows for documentation of the often surprising diversity that can be found in and around urban centers. However, it can be difficult to detect larger scale trends (such as climate change) that may influence species presence. Therefore reference sites should be selected to complement city monitoring sites. A reference site should be of the best quality and/or an ideal example of a given habitat of interest, located as near to the city as possible. For example, biodiversity monitoring in wetland habitats within the city could be compared to highly functional wetland sites in undeveloped areas outside the city.
                                        div Utilization of a reference site does not mean that the goal is for city sites to meet exactly the same parameter values as are found in a reference site. The conditions within urban and urbanizing areas are such that it is not necessarily possible to have equal values as those found within a reference site. Rather, reference sites provide the city with a yardstick to measure against and allow for tracking of larger scale change that may influence results. For example, if a particular surrogate species is experiencing a range shift due to climate change, it may gradually become undetectable in the region. By simultaneously collecting data in reference and city sites it may be possible to avoid erroneous assumptions that the change in species detection is strictly correlated to city activities or management actions.

                        div#map(style="height:400px; width:800px; margin-bottom:20px;")
                        div(id="habitatsPanel" style="margin-bottom:20px;")

                        div(style="max-width:400px;")
                            div(style="font-weight:700;") Step 5. Indicate surrogate species.
                            div(style="display:flex;") For each habitat type, choose the surrogate species you would like to track. If you have indicated a source of observations from above, species will auto-populate below and you will simply need to verify which ones you would like to include. Alternately, you can manually enter each surrogate species. Indicate the taxon of each species and then check the boxes to indicate which habitat you would like to consider for each surrogate species.
                                img(src="/images/infoIcon.svg" style="height:20px; width:20px; align-self:flex-end;" onMouseOver="this.src='/images/infoIconHover.svg'" onMouseOut="this.src='/images/infoIcon.svg'" onClick="displayInfoButton6()")
                                div(id="infoButton6" class="hidden popup" onclick="hide(document.getElementById('infoButton6'))")
                                    div(class="spaceBelow") Surrogate species are defined by the United States Fish and Wildlife Service (USFWS) as “a commonly-used scientific term for system-based conservation planning that uses a species as an indicator of landscape habitat and system conditions” (USFWS 2014a). The goal of a surrogate species approach is to use a few species to best represent the needs of the larger community (Weins et al. 2008). Depending on the objective of a given project, the characteristics used to select species differ (USFWS 2014b). The Urban Biodiversity Inventory Framework project’s primary goal is to generate a standardized approach -- a “roadmap” -- that can be used by cities to document and track urban biodiversity changes over time. With this project goal in mind, species selections should follow a set of conditions geared toward urban biodiversity representation.

                                    div(class="spaceBelow") Final species selections should highlight a range of species needs but focus primarily on species that have some level of tolerance of the urban environment. The surrogate species group should provide a representation of use of the different native regional habitats and of the different classes of native species. By using this surrogate species approach, our goal is to select species that also represent the needs of similar species or species groups and sensitive species whenever possible.

                                    div Final Surrogate species selections, both individually and as a group, should meet the following conditions:
                                    div 1. Close association/reliance on a given functional habitat type of good quality
                                    div 2. Species that are neither very rare nor overly common
                                    div 3. Species selected should represent the needs of additional species found in the given habitat type
                                    div 4. Species selected should also represent the needs of sensitive species whenever possible
                                    div 5. The group of species selected to represent a given habitat type should highlight a range of species needs provided by functional habitat but will primarily focus on species with some tolerance of the urban environment
                                    div 6. The entire suite of selected species (across taxa and habitat types) should provide a representation of the different native regional habitats and of different classes of native species

                            div(class="spaceAbove")
                                div(class="bold") Import data from pre-existing species observations.
                                div(style="margin-bottom:20px;") Indicate the sources from which you would like to pull in observations into the project. This step is optional, and you can override this information as you see fit.
                                div
                                    div(class="bold blue") iNaturalist Project
                                    div Complete the url for your iNaturalist Project below.
                                    div(class="flex spaceBelow")
                                        div https://www.inaturalist.org/
                                        input(id="input" value="test-project-for-glen")
                                        //dragonfly-creek-riparian-ubif
                                        button(onclick="processRequest()") import

                                    //div(class="bold blue") iNaturalist Trips
                                    //div Complete the url for your iNaturalist Trips below. Import each trip individually.
                                    //div(class="flex spaceBelow")
                                    //    div https://www.inaturalist.org/trips/
                                    //    input
                                    //    button(onclick="processRequest()") import

                            div(class="spaceBelow") Optionally, the user may choose to skip this step and manually enter presence/absence data rather than import.

                        //div(class="spaceAbove")
                        //    div(class="bold blue") Upload CSV
                        //    input(type="file")

                        div(style="display:flex; flex-direction:column;")
                            button(onclick="addSpecies()" class="spaceBelow spaceAbove") add species

                        div(id="example-table")

                        button(onclick="save()" class="spaceAbove") Save Program Instance

                +stickyInfoTab("UBIF Track 2 Data Entry", "infant2", "#07456b", false, "stickySecond")
                div(id="infant2" class="mapInfoContent hide" style="display:flex flex-direction:column; margin:auto;")
                        div(style="max-width:400px; margin-bottom:20px; margin:auto;")
                            //h1(class="bold spaceAbove spaceBelow") Data Entry.

                            div(class="bold") Step 1. Indicate time frame:
                            div(class="spaceBelow") Choose whether the data will be analyzed by year or month. Then enter the time frame of interest. We recommend no more than 5 time units to br compared (i.e. 5 months or 5 years).
                            div(class="flex")
                                div Time Interval: make me a radio button group
                                select(onchange="timeFrameSelected(this)")
                                    option(value = "")
                                    option(value = "month") Month
                                    option(value = "year") Year
                            div(class="flex")
                                div Time frame: from
                                input(type="date" onchange="dateStartChanged(this)")
                                div(style="margin:8px;") to
                                input(type="date" onchange="dateEndChanged(this)")

                            div(class="bold spaceAbove") Step 2. Verify data:
                            div(class="spaceBelow") Display the map of polygons and a table of the species for each polygon (select one at a time). User goes through one place/polygon at a time, and can click buttons in the species table for the user to verify presence/absence. Data is to be verified separately for each time frame.
                            div(class="spaceBelow centerContentsViaFlex" id="verifyButtons")


                            div(id="verification-table" class="hidden spaceBelow")

                            div(class="bold") Step 3. Set Targets:
                            div(class="spaceBelow") Displays current presence data for each habitat by taxa. For each habitat and each taxa, the user will enter the target presence.

                            div(class="centerContentsViaFlex")
                                button(onclick="save()" class="spaceAbove") Save

                        div(style="max-width:400px;")
                            div(style="font-weight:700;") Next Steps
                            div You have now set up your project. Next, you will be able to input the presence/absence data, see the status of observations in each place, set targets for each, and generate reports that indicate your progress towards those targets over time.

                    //button(onclick="window.location='/statusReport'" class="spaceAbove spaceBelow") Next: Status Report

                +stickyInfoTab("UBIF Track 2 Reports", "infant3", "#07456b", false, "stickyThird")
                div(id="infant3" class="mapInfoContent hide" style="display:flex flex-direction:column; margin:auto;")
                    div(style="max-width:800px; margin-bottom:20px; margin:auto;")

                        div(class="spaceAbove spaceBelow centerContentsViaFlex")
                            button(onclick="chartSites()") Chart Sites

                        h1(class="spaceAbove") Status Report

                        img(src="/images/UBHub_logo_mainwebsite.png")

                        div(class="spaceAbove") This report has been automatically generated from data entered into the indicator tracker on www.ubhub.com.
                        div(class="spaceAbove") The Urban Biodiversity Inventory Framework (UBIF) is a standardized system for local governments to measure the status of biodiversity in an urban environment. It was first developed in 2017 in a partnership effort under the Urban Sustainability Directors Network (USDN). In the UBIF system, adherents choose surrogate species which will serve as proxy indicators for biodiversity status. They will also indicate particular places within which to track these species. Data is then tracked by taxonomic group and habitat type over time to measure progress.
                        div(class="spaceAbove") Adherents to UBIF can select from three different methods, or “tracks”. Track 2, used here, calls for species observations to include both presence and absence data for each habitat type. Adherents to UBIF Track 2 set goals for the presence of surrogate species in each habitat and taxon and track their progress over time.

                        h2(class="spaceAbove") Section 1: Overview of Surrogate Species

                        h2(class="spaceAbove centerText") Observations of Surrogate Species in All Habitats of Interest

                        div(style="border:solid; width:500px; height:300px; margin:auto;")
                            svg(id="observationsPerSiteByTaxon" class="chart")

                        h2 Observations of Surrogate Species in All Habitats of Interest Over Time

                        div(style="border:solid; width:500px; height:300px; margin:auto;")
                            svg(id="observationsOfSurrogateSpeciesInAllHabitatsOverTime" class="chart")

                        h2 Section 2: Overview of Species by Habitat Type

                        h2 Surrogate Species in selected Habitat
                        div(class="spaceAbove spaceBelow centerContentsViaFlex" id="surrogateSpeciesByHabitatChartButtons")

                        div(style="border:solid; width:500px; height:300px; margin:auto;")
                            svg(id="surrogateSpeciesByHabitatChart" class="chart")

                        h2 Presence/Absence of Surrogate Species Within ____ Taxa by Habitat

                        div(class="spaceAbove spaceBelow centerContentsViaFlex" id="taxaButtons")
                            button Birds
                            button Invertebrates
                            button Plants

                        div(style="border:solid; width:500px; height:300px; margin:auto;")
                            svg(class="chart")

                        h2 Section 3: Status of Surrogate Species in ____ Habitat
                        div Overview chart, then up to 6 charts (one for each taxon) showing data from each place

                        div(style="border:solid; width:500px; height:300px; margin:auto;")
                            svg(class="chart")

                        h2 Appendix: Tables of Species Presence Data
                        div Table for each habitat type listing the species names and indicating presence/absence/unknown status for each according to place and time frame.
                        div(class="spaceAbove spaceBelow centerContentsViaFlex" id="surrogateSpeciesByHabitatButtons")
                        div(id="speciesPresenceTable" class="spaceAbove spaceBelow hidden")


    +footer()