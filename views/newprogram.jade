doctype html
include mixins
html
    head
        style.
            .bar-chart {
                border: solid;
            }
            .newSite {
                display: flex;
                padding: 10px;
                background: lightgrey;
            }
            .newSite svg {
                margin: 10px;
            }
        link(href="https://unpkg.com/tabulator-tables@4.2.3/dist/css/tabulator.min.css" rel="stylesheet")
        script(type="text/javascript" src="https://unpkg.com/tabulator-tables@4.2.3/dist/js/tabulator.min.js")
        link(rel='stylesheet', href='/stylesheets/style.css')
        script(src="https://d3js.org/d3.v5.min.js")
        script(async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAEKjvE48-VV37P2pGBWFphvlrx8BXGDCs&libraries=drawing,geometry")
        script.
            var sites = [];
            var polygon;
            var table;
            var columns;
            let habitats = [];
            window.onload = function (ev) {
                initMapOnPage();

                var tableData = [{"species": "", "taxa": ""}];

                columns = [
                    {title: "Species", field: "species", editor: "input"},
                    {title: "Taxa", field: "taxa", editor: "select", editorParams: {"Plant": "Plant", "Bird": "Bird", "Invert Pollinator": "Invert Pollinator"}
                    }];

                table = new Tabulator("#example-table", {
                    data: tableData,           //load row data from array
                    layout: "fitColumns",      //fit columns to width of table
                    responsiveLayout: "hide",  //hide columns that dont fit on the table
                    tooltips: true,            //show tool tips on cells
                    addRowPos: "bottom",          //when adding a new row, add it to the top of the table
                    history: true,             //allow undo and redo actions on the table
                    pagination: "local",       //paginate the data
                    paginationSize: 7,         //allow 7 rows per page of data
                    movableColumns: true,      //allow column order to be changed
                    resizableRows: true,       //allow row order to be changed
                    initialSort: [             //set the initial sort order of the data
                        {column: "name", dir: "asc"},
                    ],
                    columns: columns});
            };

            function initMapOnPage() {
                center = {lat: 20, lng: 15};
                map = new google.maps.Map(document.getElementById('map'), {
                    zoom: 2, streetViewControl: false,
                    center: center,
                    styles: [{"elementType": "geometry", "stylers": [{"color": "#b6d5e3"}]},
                        {"elementType": "labels.text.fill", "stylers": [{"color": "#6da4c7"}]},
                        {"elementType": "labels.text.stroke", "stylers": [{"color": "#b6d5e3"}]},
                        {"featureType": "administrative", "stylers": [{"visibility": "simplified"}]},
                        {"featureType": "administrative", "elementType": "geometry", "stylers": [{"color": "#f2f2f2"}]},
                        //country borders color is next line
                        {
                            "featureType": "administrative",
                            "elementType": "geometry.stroke",
                            "stylers": [{"color": "#ffffff"}, {"visibility": "on"}]
                        },
                        //main labels color is the next line
                        {
                            "featureType": "administrative",
                            "elementType": "labels.text",
                            "stylers": [{"color": "#939393"}]
                        },
                        //urban land color is next line
                        {"featureType": "landscape", "stylers": [{"color": "#cccccc"}]},
                        {
                            "featureType": "landscape.man_made",
                            "elementType": "geometry.stroke",
                            "stylers": [{"color": "#334e87"}]
                        },
                        //main land color is the next line
                        {"featureType": "landscape.natural", "stylers": [{"color": "#d3e9d5"}]},
                        {"featureType": "poi", "stylers": [{"visibility": "off"}]},
                        {"featureType": "poi", "elementType": "geometry", "stylers": [{"color": "#283d6a"}]},
                        {"featureType": "poi", "elementType": "labels.text.fill", "stylers": [{"color": "#6f9ba5"}]},
                        {"featureType": "poi", "elementType": "labels.text.stroke", "stylers": [{"color": "#1d2c4d"}]},
                        //park areas color is next line
                        {"featureType": "poi.park", "stylers": [{"color": "#b8ddc3"}, {"visibility": "simplified"}]},
                        {"featureType": "poi.park", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {"featureType": "poi.park", "elementType": "labels.icon", "stylers": [{"visibility": "off"}]},
                        //road color is the next line
                        {"featureType": "road", "elementType": "geometry", "stylers": [{"color": "#f2f2f2"}]},
                        {"featureType": "road", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {"featureType": "road", "elementType": "labels.text.fill", "stylers": [{"color": "#4e6d70"}]},
                        {"featureType": "road", "elementType": "labels.text.stroke", "stylers": [{"color": "#f2f2f2"}]},
                        {"featureType": "road.arterial", "stylers": [{"visibility": "simplified"}]},
                        {
                            "featureType": "road.arterial",
                            "elementType": "geometry",
                            "stylers": [{"visibility": "simplified"}]
                        },
                        {"featureType": "road.arterial", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {"featureType": "road.highway", "stylers": [{"visibility": "simplified"}]},
                        {"featureType": "road.highway", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {
                            "featureType": "road.highway",
                            "elementType": "labels.text.fill",
                            "stylers": [{"color": "#4e6d70"}]
                        },
                        {
                            "featureType": "road.highway",
                            "elementType": "labels.text.stroke",
                            "stylers": [{"color": "#f2f2f2"}]
                        },
                        //transit lines and land area polygons are the next line
                        {"featureType": "transit", "stylers": [{"color": "#b2b2b2"}]},
                        {"featureType": "transit", "elementType": "labels", "stylers": [{"visibility": "off"}]},
                        {
                            "featureType": "transit",
                            "elementType": "labels.text.fill",
                            "stylers": [{"color": "#98d2b2"}]
                        },
                        {
                            "featureType": "transit",
                            "elementType": "labels.text.stroke",
                            "stylers": [{"color": "#F2F2F2"}]
                        },
                        {"featureType": "water", "stylers": [{"color": "#b6d5e3"}]},
                        {"featureType": "water", "elementType": "labels.text.fill", "stylers": [{"color": "#4e6d70"}]}]
                });
                var drawingManager = new google.maps.drawing.DrawingManager({
                    drawingMode: google.maps.drawing.OverlayType.POLYGON,
                    drawingControl: true,
                    drawingControlOptions: {
                        position: google.maps.ControlPosition.TOP_CENTER,
                        drawingModes: ['polygon']
                    },
                    markerOptions: {icon: 'https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png'},
                    circleOptions: {
                        fillColor: '#ffff00',
                        fillOpacity: 1,
                        strokeWeight: 5,
                        clickable: false,
                        editable: true,
                        zIndex: 1
                    }
                });
                drawingManager.setMap(map);
                google.maps.event.addListener(drawingManager, 'overlaycomplete', function (event) {
                    if (event.type == 'circle') {
                        var radius = event.overlay.getRadius();
                    }
                    if (event.type == 'polygon') {
                        polygon = event.overlay.getPath().getArray();
                        var site = {
                            taxa: [],
                            polygon: polygon,
                            coordinates: [],
                            minX: 1000,
                            minY: 1000,
                            maxX: -1000,
                            maxY: -1000
                        }
                        for (var i = 0; i < polygon.length; i++) {
                            console.log(polygon[i].lat() + ", " + polygon[i].lng());
                            site.coordinates.push({lat: polygon[i].lat(), lng: polygon[i].lng()})
                            if(polygon[i].lat() * -1 + 90 < site.minY) {
                                site.minY = polygon[i].lat() * -1 + 90;
                            }
                            if(polygon[i].lat() * -1 + 90 > site.maxY) {
                                site.maxY = polygon[i].lat() * -1 + 90;
                            }
                            if (polygon[i].lng() + 180 < site.minX) {
                                site.minX = polygon[i].lng() + 180;
                            }
                            if (polygon[i].lng() + 180 > site.maxX) {
                                site.maxX = polygon[i].lng() + 180;
                            }
                        }
                        addSiteToUi(site);
                        sites.push(site)
                        console.log(sites);
                    }
                });
            }
            function addSiteToUi(site) {
                let siteElement = document.createElement("DIV");
                siteElement.className = "newSite";
                let siteSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                siteSvg.setAttribute("height", "30px");
                siteSvg.setAttribute("width", "60px");
                let viewBox = site.minX + " " + site.minY + " " + (site.maxX - site.minX) + " " + (site.maxY - site.minY);
                siteSvg.setAttribute("viewBox", viewBox);
                let sitePolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');

                let points = "";
                for(let i = 0; i < site.coordinates.length; i++) {
                    points += (site.coordinates[i].lng + 180) + " " + (site.coordinates[i].lat * -1 + 90);
                    if(i < site.coordinates.length - 1) {
                        points += " ";
                    }
                }
                sitePolygon.setAttribute('points', points);

                siteSvg.appendChild(sitePolygon);
                siteElement.appendChild(siteSvg);

                let siteData = document.createElement("DIV");
                siteData.setAttribute("style", "display: flex; flex-direction:column;")
                let siteName = document.createElement("DIV");
                siteData.appendChild(siteName);
                siteName.innerText = "Site Name";
                let siteInput = document.createElement("INPUT");
                siteData.appendChild(siteInput);
                let siteHabitat = document.createElement("DIV");
                siteData.appendChild(siteHabitat);
                siteHabitat.innerText = "Habitat Select";
                let siteHabitatSelector = document.createElement("SELECT")
                for(let i = 0; i < habitats.length ; i++) {
                    let option = document.createElement("OPTION")
                    option.appendChild(document.createTextNode(habitats[i]));
                    siteHabitatSelector.appendChild(option);
                }

                siteData.appendChild(siteHabitatSelector);

                siteHabitatSelector.onchange = function (selection) {
                    console.log(selection);
                };

                siteElement.appendChild(siteData);

                document.getElementById("chart").appendChild(siteElement);
            }

body
    +header(true)

    div(style="padding-top:40px;")

    if queryId
        if queryId == 1
            div(style="margin:auto; min-width:800px; display:flex; flex-direction:column; align-items:center;")
                div(style="max-width:400px;")
                    //img(src="/images/ubif-logo.png" class="spaceBelow")
                    h1(class="bold") UBIF Track 2 Project Setup
                    div(class="flex spaceBelow") In the Urban Biodiversity Inventory Framework (UBIF), Track 2 system, cities indicate surrogate species they would like to track for each habitat type in their city.  Here you will set up the parameters of your project.
                        img(src="/images/infoIcon.svg" style="height:20px; width:20px; align-self:flex-end;" onMouseOver="this.src='/images/infoIconHover.svg'" onMouseOut="this.src='/images/infoIcon.svg'" onClick="displayInfoButton0()")
                        div(id="infoButton0" class="hidden popup" onclick="hide(document.getElementById('infoButton0'))")
                            div Purposefully collecting data to assess urban biodiversity provides cities the ability to generate summary statistics and track changes over time in a more measurable way than is provided by conducting Track 1 data collection only. Track 2 employs presence/absence monitoring of species as a way to track and assess urban biodiversity. Recording the presence of species in Track 1 is valuable information, but knowing where species are not is also essential to assist in decision making for restoration action or other management decisions that can be applied to improve habitat quality and/or quantity.
                            div Two major decisions must be made before presence/absence monitoring can begin: Which species will be surveyed for, and what locations will be surveyed. With unlimited resources, a city could attempt to exhaustively record all species of all taxa at every possible location. However, given normal limitations, this is an unattainable goal. In order to best use limited resources, a surrogate species approach (Caro 2010) and recommendations for selecting reference sites within as well as outside of the city, are employed for Track 2 and Track 3.

                    div(style="margin-bottom:20px;") <b>Step 1. Name your project</b>
                        div Choose a name to encompass the entire UBIF Track 2 initiative for your city through time as long as it maintains the same overall structure (such as taxon). Only small changes to the project can be accommodated without starting a new project.
                        div(class="bold blue smallSpaceAbove") Enter Project Name
                        input
                        div(class="bold blue smallSpaceAbove") Enter Project Description
                        textarea(rows="3" class="fullWidth")

                    div(style="margin-bottom:20px;") <b>Step 2. Indicate Taxonomic Groups</b>
                        div(style="display:flex;") Surrogate species must be indicated in at least five different taxonomic groups. The first three of these groups are birds, plants, and invertebrate pollinators. The remaining two are customizable by city. Indicate those here.
                            img(src="/images/infoIcon.svg" style="height:20px; width:20px; align-self:flex-end;" onMouseOver="this.src='/images/infoIconHover.svg'" onMouseOut="this.src='/images/infoIcon.svg'" onClick="displayInfoButton2()")
                            div(id="infoButton2" class="hidden popup" onclick="hide(document.getElementById('infoButton2'))")
                                div As cities consider surrogate species selections, the first criteria is to select species from diverse taxa groups that are typically found in or are obligate to a given habitat type of good quality and are neither very rare nor overly common.  The plant, bird and invertebrate pollinator taxa groups are universal throughout cities utilizing the UBIF. However, additional taxa groups are chosen at the discretion of the cities, with at least two additional taxa groups recommended.

                        div(class="flex column smallSpaceAbove")
                            div(class="bold blue") Enter Taxa
                            div(class="flex")
                                input(id="taxonNameId")
                                button(onclick="addTaxon()") add taxon
                            div(class="taxon boxedChildren smallSpaceAbove")
                                div Bird
                                div Plant
                                div Invertebrate Pollinator

                    div(style="margin-bottom:20px;") <b>Step 3. Indicate your habitats of interest.</b>
                        div Indicate the various habitats that you will be tracking in this project. The type and number of habitats of interest should be based on known native habitats found currently or historically within the city and is completely up to the individual city’s discretion. Note that the surrogate species will be the same across each habitat. Some examples include: prairie, wetland, freshwater, douglas fir forest, brownfields.
                        div(class="flex column smallSpaceAbove")
                            div(class="bold blue") Enter Habitats
                            div(class="flex")
                                input(id="habitatNameId")
                                button(onclick="addHabitat()") add habitat
                            div(class="habitat boxedChildren smallSpaceAbove")

                    div(class="spaceBelow") <b>Step 4. Indicate places of interest.</b>
                     div(class="flex") Draw a polygon on the map below for each place (such as a park) of interest. Name each place accordingly. Note that each place can only have one habitat type, so it may be appropriate to divide certain parks into multiple places if they cover more than one habitat type. The polygon shapes will be used to pull data from species observations databases in a later step. For each habitat type, you may indicate one place to serve as a reference monitoring site. Reference sites represent desirable conditions for other places of the same habitat type and provide a yardstick to measure the other places of the same habitat against.
                         img(src="/images/infoIcon.svg" style="height:20px; width:20px; align-self:flex-end;" onMouseOver="this.src='/images/infoIconHover.svg'" onMouseOut="this.src='/images/infoIcon.svg'" onClick="displayInfoButton4()")
                         div(id="infoButton4" class="hidden popup" onclick="hide(document.getElementById('infoButton4'))")
                                div(class="spaceBelow") From large protected natural areas to small vegetated parking strips, habitat quality and quantity within cities varies greatly. The best utilization of the UBIF, as a means to attain a comprehensive analysis of biodiversity in the city, requires that a diversity of sites be selected. In this way, care should be taken to select sites with a range of perceived quality and avoid the temptation to only select the “best” or “favorite” sites within the city.
                                div(class="spaceBelow") Collecting biodiversity data exclusively within the city allows for documentation of the often surprising diversity that can be found in and around urban centers. However, it can be difficult to detect larger scale trends (such as climate change) that may influence species presence. Therefore reference sites should be selected to complement city monitoring sites. A reference site should be of the best quality and/or an ideal example of a given habitat of interest, located as near to the city as possible. For example, biodiversity monitoring in wetland habitats within the city could be compared to highly functional wetland sites in undeveloped areas outside the city.
                                div Utilization of a reference site does not mean that the goal is for city sites to meet exactly the same parameter values as are found in a reference site. The conditions within urban and urbanizing areas are such that it is not necessarily possible to have equal values as those found within a reference site. Rather, reference sites provide the city with a yardstick to measure against and allow for tracking of larger scale change that may influence results. For example, if a particular surrogate species is experiencing a range shift due to climate change, it may gradually become undetectable in the region. By simultaneously collecting data in reference and city sites it may be possible to avoid erroneous assumptions that the change in species detection is strictly correlated to city activities or management actions.

                div(style="display:flex; margin:auto;")
                div(style="max-width:400px; margin-bottom:20px;")
                    h1(class="bold spaceAbove spaceBelow") Data Entry.
                    div
                        div(class="bold") Step 1. Draw data from pre-existing species observations.
                        div(style="margin-bottom:20px;") Indicate the sources from which you would like to pull in observations into the project. This step is optional, and you can override this information as you see fit.
                        div
                            div(class="bold blue") iNaturalist Project
                            div Complete the url for your iNaturalist Project below.
                            div(class="flex spaceBelow")
                                div https://www.inaturalist.org/
                                input(id="input" value="dragonfly-creek-riparian-ubif")
                                button(onclick="processRequest()") import

                            div(class="bold blue") iNaturalist Trips
                            div Complete the url for your iNaturalist Trips below. Import each trip individually.
                            div(class="flex spaceBelow")
                                div https://www.inaturalist.org/trips/
                                input
                                button(onclick="processRequest()") import

                    div(class="spaceBelow") Optionally, the user may choose to skip this step and manually enter presence/absence data rather than import. This can be done in step 3.

                    div(class="bold") Step 2. Indicate time frame:
                    div(class="spaceBelow") User chooses whether the data will be analyzed by year or month. Then they will enter the year(s) or month(s) of interest. For example, they choose “Year” and then say years 2010 and 2015 are of interest. Or, they choose “Month” and then say Nov-Dec 2017 and March-April 2018 are of interest. Maximum of 5 time frames.

                    div(class="bold") Step 3. Verify data:
                    div(class="spaceBelow") Display the map of polygons and a table of the species for each polygon (select one at a time). User goes through one place/polygon at a time, and can click buttons in the species table for the user to verify presence/absence. Data is to be verified separately for each time frame.

                    div(class="bold") Step 4. Set Targets:
                    div(class="spaceBelow") Displays current presence data for each habitat by taxa. For each habitat and each taxa, the user will enter the target presence.

                div#map(style="height:400px; width:800px; margin-bottom:20px;")

                div(id="chart" style="margin-bottom:20px;")

                div(style="max-width:400px;")
                    div(style="font-weight:700;") Step 5. Indicate surrogate species.
                    div(style="display:flex;") For each habitat type, choose the surrogate species you would like to track. If you have indicated a source of observations from above, species will auto-populate below and you will simply need to verify which ones you would like to include. Alternately, you can manually enter each surrogate species. Indicate the taxon of each species and then check the boxes to indicate which habitat you would like to consider for each surrogate species.
                        img(src="/images/infoIcon.svg" style="height:20px; width:20px; align-self:flex-end;" onMouseOver="this.src='/images/infoIconHover.svg'" onMouseOut="this.src='/images/infoIcon.svg'" onClick="displayInfoButton6()")
                        div(id="infoButton6" class="hidden popup" onclick="hide(document.getElementById('infoButton6'))")
                            div(class="spaceBelow") Surrogate species are defined by the United States Fish and Wildlife Service (USFWS) as “a commonly-used scientific term for system-based conservation planning that uses a species as an indicator of landscape habitat and system conditions” (USFWS 2014a). The goal of a surrogate species approach is to use a few species to best represent the needs of the larger community (Weins et al. 2008). Depending on the objective of a given project, the characteristics used to select species differ (USFWS 2014b). The Urban Biodiversity Inventory Framework project’s primary goal is to generate a standardized approach -- a “roadmap” -- that can be used by cities to document and track urban biodiversity changes over time. With this project goal in mind, species selections should follow a set of conditions geared toward urban biodiversity representation.

                            div(class="spaceBelow") Final species selections should highlight a range of species needs but focus primarily on species that have some level of tolerance of the urban environment. The surrogate species group should provide a representation of use of the different native regional habitats and of the different classes of native species. By using this surrogate species approach, our goal is to select species that also represent the needs of similar species or species groups and sensitive species whenever possible.

                            div Final Surrogate species selections, both individually and as a group, should meet the following conditions:
                            div 1. Close association/reliance on a given functional habitat type of good quality
                            div 2. Species that are neither very rare nor overly common
                            div 3. Species selected should represent the needs of additional species found in the given habitat type
                            div 4. Species selected should also represent the needs of sensitive species whenever possible
                            div 5. The group of species selected to represent a given habitat type should highlight a range of species needs provided by functional habitat but will primarily focus on species with some tolerance of the urban environment
                            div 6. The entire suite of selected species (across taxa and habitat types) should provide a representation of the different native regional habitats and of different classes of native species

                div(class="spaceAbove")
                    div(class="bold blue") Upload CSV
                    input(type="file")

                div(style="display:flex; flex-direction:column;")
                    button(onclick="addSpecies()" class="spaceBelow spaceAbove") add species

                div(id="example-table")

                svg(class="hidden")
                button(onclick="updateMap()" class="hidden") Update Map
                button(onclick="save()" class="spaceAbove") Save

                div(style="max-width:400px;")
                    div(style="font-weight:700;") Next Steps
                    div You have now set up your project. Next, you will be able to input the presence/absence data, see the status of observations in each place, set targets for each, and generate reports that indicate your progress towards those targets over time.

                button(onclick="window.location='/statusReport'" class="spaceAbove spaceBelow") Next: Status Report


    +footer()

footer
    script.
        function addHabitat() {
            habitatNameElement = document.getElementById("habitatNameId");
            let newHabitat = {title: habitatNameElement.value, field: habitatNameElement.value, width:90,  align:"center", formatter:"tickCross", sorter:"boolean", editor:true}
            habitats.push(habitatNameElement.value);
            columns.push(newHabitat);
            table.setColumns(columns);
            newHabitatLabel = document.createElement("DIV");
            newHabitatLabel.textContent = habitatNameElement.value
            document.getElementsByClassName("habitat")[0].appendChild(newHabitatLabel);
            habitatNameElement.value = "";
        }

        function addTaxon() {
            taxonNameElement = document.getElementById("taxonNameId");
            columns[1].editorParams[taxonNameElement.value] = taxonNameElement.value;
            table.setColumns(columns);
            newTaxonLabel = document.createElement("DIV");
            newTaxonLabel.textContent = taxonNameElement.value
            document.getElementsByClassName("taxon")[0].appendChild(newTaxonLabel);
            taxonNameElement.value = "";
        }

        function addSpecies() {
            table.addRow();
        }

        function save() {
            console.log(table.getData());
        }

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        var markers = [];

        processRequest = function() {
            getINaturalistData().then(placeMarkers);
        }

        getINaturalistData = function() {
            return new Promise(function(resolve) {
                iNaturalistProjectId = document.getElementById("input").value;
                iNaturalistProjectId = encodeURIComponent(iNaturalistProjectId);
                document.getElementById("input").value = "";

                var xhr = new XMLHttpRequest();

                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 3) {

                    } else if (xhr.readyState == 4 && xhr.status == 200) {
                        resolve(JSON.parse(xhr.responseText));
                    }
                };

                xhr.open("GET", "https://inaturalist.org/observations/project/" + iNaturalistProjectId + ".json", true);
                xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
                xhr.send();
            });
        }

        placeMarkers = function(observations) {
            greyImage = {
                url: '/images/marker_0_grey_39x59.png',
                scaledSize: new google.maps.Size(20, 30)
            };
            for (observation in observations) {
                var position = {
                    lat: parseFloat(observations[observation].latitude),
                    lng: parseFloat(observations[observation].longitude)
                };
                var marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    icon: greyImage
                });
                marker.taxon = observations[observation].iconic_taxon_name;
                marker.species = observations[observation].species_guess;
                marker.presence = Math.random() >= 0.5;
                markers.push(marker);
            }
            updateMap();
        }

        updateMap = function() {
            var minLat, maxLat, minLng, maxLng;
            for(i = 0; i < markers.length; i++) {
                if(minLat == null || markers[i].getPosition().lat() < minLat)
                    minLat = markers[i].getPosition().lat();
                if (maxLat == null || markers[i].getPosition().lat() > maxLat)
                    maxLat = markers[i].getPosition().lat();
                if (minLng == null || markers[i].getPosition().lng() < minLng)
                    minLng = markers[i].getPosition().lng();
                if (maxLng == null || markers[i].getPosition().lng() > maxLng)
                    maxLng = markers[i].getPosition().lng();
            }

            var polygons = [];

            // for(i = 0; i < 4; i++) {
            //
            //     switch (i) {
            //         case 0:
            //             westBound = minLng;
            //             eastBound = minLng + (maxLng - minLng) / 4;
            //             break;
            //         case 1:
            //             westBound = minLng + (maxLng - minLng) / 4;
            //             eastBound = minLng + ((maxLng - minLng) / 4) * 2;
            //             break;
            //         case 2:
            //             westBound = minLng + ((maxLng - minLng) / 4) * 2;
            //             eastBound = minLng + ((maxLng - minLng) / 4) * 3;
            //             break;
            //         case 3:
            //             westBound = minLng + ((maxLng - minLng) / 4) * 3;
            //             eastBound = maxLng;
            //             break;
            //     }

            //     polygons[i].polygon = new google.maps.Rectangle({
            //         strokeColor: '#000000',
            //         strokeOpacity: 1.0,
            //         strokeWeight: 1,
            //         fillColor: '#FFFFFF',
            //         fillOpacity: 0.0,
            //         map: map,
            //         bounds: {
            //             north: maxLat,
            //             south: minLat,
            //             east: eastBound,
            //             west: westBound
            //         }
            //     });
            // }

            for(i = 0; i < markers.length; i++) {
                for(k = 0; k < sites.length; k++) {
                    if(sites[k].polygon.getBounds().contains(markers[i].getPosition())) {
                        sites[k].markers.push(markers[i]);
                        break;
                    }
                }
            }

            // for(polygon in polygons) {
            //     for(marker in polygons[polygon].markers) {
            //         console.log(polygons[polygon].markers[marker].species);
            //         console.log(polygons[polygon].markers[marker].taxon);
            //         console.log(polygons[polygon].markers[marker].presence);
            //     }
            // }

            chart(sites);

            var rectangle = new google.maps.Rectangle({
                strokeColor: '#FFFFFF',
                strokeOpacity: 0.0,
                strokeWeight: 2,
                fillColor: '#FF0000',
                fillOpacity: 0.35,
                map: map,
                bounds: {
                    north: maxLat,
                    south: minLat,
                    east: maxLng,
                    west: minLng
                }
            });

            map.fitBounds(rectangle.getBounds());

            map.setCenter({lat: ((maxLat - minLat) / 2 + minLat), lng: ((maxLng - minLng) / 2 + minLng)});
            map.setZoom(17);
        }

        chart = function(polygons) {
            var svgWidth = 500;
            var svgHeight = 300;
            var svg = d3.select('svg')
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .attr("class", "bar-chart");

            svg.selectAll("rect")
                .data(polygons)
                .enter()
                .append("rect")
                .attr("height", function (d) {
                    // console.log(d);
                    var presence = 0;
                    for(marker in d.markers) {
                        if(d.markers[marker].presence)
                            presence += 1;
                    }
                    presence = svgHeight * (presence / d.markers.length);
                    d.presence = presence;
                    return presence;
                })
                .style("stroke", "white")
                .style("fill", "grey")
                .style("stroke-width", 5)
                .attr("y", function (d) {return svgHeight - d.presence;})
                .attr("width", svgWidth / polygons.length)
                .attr("transform", function (d, i) {
                    var translate = [i * svgWidth / polygons.length, 0];
                    return "translate(" + translate + ")";
                });
        }

        function hide(element) {
            element.classList.add("hidden");
        }

        function displayInfoButton0() {
            document.getElementById("infoButton0").classList.remove("hidden");
        }

        function displayInfoButton2() {
            document.getElementById("infoButton2").classList.remove("hidden");
        }

        function displayInfoButton4() {
            document.getElementById("infoButton4").classList.remove("hidden");
        }

        function displayInfoButton6() {
            document.getElementById("infoButton6").classList.remove("hidden");
        }
